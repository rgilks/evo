# Rob's Evolution Simulation Rules - Simplified

## Core Design
Minimize special cases by refactoring to use components
Each component/system/function should have single responsibility
Use descriptive names that clearly indicate purpose
Write clear readable code first, optimize bottlenecks later
Keep systems focused on specific component sets
Group related components near each other
Organize code by domain, not technical concerns
Document complex algorithms explaining "why" not just "what"

## Rayon Parallelism
Use Rayon for CPU-intensive operations on large datasets
Apply to operations that don't depend on each other's results
Prefer par_iter() over manual thread spawning
Use par_iter_mut() for mutable operations
Avoid nested parallelism
Keep parallel blocks focused
Use join() for divide-and-conquer algorithms

## Hecs ECS Design
Keep components small and focused on one aspect
Use composition for complex behavior
Components should contain data, systems contain logic
Use meaningful component names
Query only what you need with specific component combinations
Use Query for read-only access, QueryBorrow for mutable access
Group related systems together
Keep systems stateless between calls

## Performance
Profile first to identify bottlenecks
Optimize hot paths that run frequently
Choose data structures based on access patterns
Minimize allocations and reuse containers
Use #[inline] sparingly for small frequently called functions
Prefer stack allocation for small short-lived data
Use Vec for dynamic collections
Consider SmallVec for small collections that occasionally grow
Use Arc for shared immutable data

## Logging and Debugging
Include entity counts and relevant metrics
Avoid log flooding with appropriate log levels
Use structured logging with context
Add debug components for visualization
Use conditional compilation for debug features
Provide inspection tools for entity state

## Testing
Test systems in isolation with minimal worlds
Test component combinations and edge cases
Use property-based testing for complex algorithms
Test system interactions and performance characteristics
Test memory usage for long-running simulations

## Code Style
Follow Rust naming conventions (snake_case, PascalCase)
Use rustfmt for consistent formatting
Use clippy and fix all warnings
Write idiomatic Rust patterns
Document public APIs with examples
Document invariants and constraints
Keep documentation up to date

## Evolution-Specific
Use components for genetic traits
Design components for easy mutation during evolution
Support parent-child inheritance relationships
Handle entity type extinction gracefully
Separate evolution logic from rendering/UI
Design for large populations and scalability
Make simulation parameters easily adjustable
Enable easy experimentation and modification

## Development Workflow
Simplicity first - code should be concise and elegant
Keep README file up to date
Keep .gitignore file up to date
Be rigorous in fixing warnings and errors
When typing 'rcp': review changes, remove pointless comments, run checks/tests, update docs, git add/commit/push
